<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Введение в Scala</title>

		<meta name="description" content=" ... ">
		<meta name="author" content="Vetrov Sergey">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<!-- <link rel="stylesheet" href="css/user_css.css"> -->
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/night.css" id="theme">


		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">

		<script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>


		<style type="text/css">
    :root {
        --r-main-font-size: 25px;
    }
</style>


	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides" style="font-size: 1.3em; line-height: 1.25em; text-align: left">

<section>
	<h2>Введение в Scala</h2>
	<h2>Основные типы. Ввод и вывод.</h2>
	<img src="https://www.scala-lang.org/resources/img/frontpage/scala-spiral.png" width="85px" margin-bottom=0> 


	<p>Кафедра ИВТ и ПМ. Ветров С. В.</p>

	<br>
	<div align="right"><a href="https://github.com/ivtipm/BigDataLanguages/blob/main/Scala/Readme.md">короткая шпаргалка</a></div>
</section>


<!-- ====================================================================== hello, world! -->
<section>
	
<section data-auto-animate>
	<h2>Hello, World!</h2>
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
@main
def main(): Unit = {
  	println("Hello")
	  println("world!")
}
	</code></pre>
</section>



<section data-auto-animate>
	<h2>Hello, World!</h2>
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
	@main
	def main() =
	    println("Hello")
	    println("world!")

	</code></pre>
</section>






<section data-auto-animate>
	<h2>Hello, World!</h2>
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
	@main
	def main() =
	    println("Hello world!")
	    println("Hello world!")
	</code></pre>

	<ul>
		<li><code>@main</code> — аннотация, помечающая текущий метод как главную функцию программы. Тело функции начинается после =. Фигурные скобки вокруг тела писать необязательно.</li>
	</ul>
</section>


<section data-auto-animate>
	<h2>Hello, World!</h2>
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
	@main
	def main() =
	    println("Hello world!")
	    println("Hello world!")
	</code></pre>

	<ul>
		<li><code>@main</code> — аннотация, помечающая текущий метод как главную функцию программы. Тело функции начинается после =. Фигурные скобки вокруг тела писать необязательно.</li>

		<li>Если фигурных скобок нет, то вложенность определяют отступы (как в Python).</li>

		<li>В стандарте Scala 2 нужно создать класс наследник от App, который будет включать основной код.</li>
	</ul>
</section>


<section data-markdown>
	## Компиляция и запуск
	```scala
	@main
	def main_method() =
	    println("Hello world!")
	```

```text[1-2|5-14|16-18]
# Компиляция 
scalaс main.scala


# Результат:
main.scala
# class файлы для каждого пакета, класса, метода
main$package$.class
main$package.class
main_method.class 
# TASTy = Typed Abstract Syntax Trees
main$package.tasty
main_method.tasty


# Запуск, нужно указать только имя главного метода
scala main_method
```
</section>



</section>



<!-- ====================================================================== типы -->
<section>

<section data-markdown>
## Система типов
- Статическая типизация
- Местами строгая (нельзя без явного преобразования `val x: Int = 2.3`)
- Возможен автоматический вывод типа (inference) для многих ситуаций.\
  Например `val y: = 40+2; // Int`

</section>


<section data-auto-animate>
Общий синтаксис объявления переменной или константы
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
val|var name: type = value
</code></pre>
</section>

<section data-auto-animate>
Общий синтаксис объявления переменной или константы
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
val|var name: type = value
</code></pre>
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
val my_const = 333/106;   		// константа (immutable variable)
var my_variable:Int = 0;      // переменная
</code></pre>


</section>

<section data-auto-animate>
Общий синтаксис объявления переменной или константы
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
val|var name: type = value
</code></pre>
	<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
val my_const = 333/106;   		// константа (immutable variable)
var my_variable:Int = 0;      // переменная
</code></pre>

<ul>
	<li>Тип у переменных указывать тоже не обязательно, но рекомендуется.</li>
	<li>Используйте константы всюду, где это возможно</li>
</ul>
</section>


<section>
	<img src="https://github.com/ivtipm/BigDataLanguages/raw/main/Scala/ScalaTypes.drawio.png">
</section>

<section>
	<h2>Числовые типы (value типы)</h2>
	</code></pre>
		<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
	val b: Byte = 1
	val i: Int = 1 				// default for type inference
	val l: Long = 1
	val s: Short = 1
	val d: Double = 2.0 	// default for type inference
	val f: Float = 3.0e2  // 3.0 * 10 ^ 2
	</code></pre>
</section>

<section>
	<h2>Строки</h2>
Такие же как в Java
	</code></pre>
		<pre class="scala"><code data-trim data-noescape style="font-size: 1.0em;line-height: 1.25em;">
val x = 333.0/106;		

// Интерполяция строк
val S = s"pi = $x"
// pi = 3.141509433962264

val S2 = s"выражение внутри строки: ${ Math.pow(x.ceil,2) }"

// многострочный литерал
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""

// многострочный литерал, без пробелов вначале
val quote = """The essence of Scala:
               |Fusion of functional and object-oriented
               |programming in a typed setting.""".stripMargin

	</code></pre>
</section>



<section>
	<h2>Строки</h2>
Интерполяция
	</code></pre>
	<p><code>s, f</code> и <code>raw</code> - префиксы для строк</p>
	<p><code>s</code> - префиксы строки с интерполяцией</p>
		<pre class="scala"><code data-trim data-noescape style="font-size: 1.1em;line-height: 1.25em;">
val name = "James"
println( s"Hello, $name" )  // Hello, James	

// интерполяция с выражениями внутри {}
println( s"5 = ${2+2}" )  // Hello, James	

// экранирование знака доллара
println( s"price = $$99.5" )  // price = $99.5
	</code></pre>
</section>


<section>
	<h2>Строки</h2>
Интерполяция и форматирование
	</code></pre>
	<p><code>f</code> - префиксы строки с интерполяцией и форматированием</p>
	<p>Параметры форматирование записываются после знака <code>%</code></p>
		<pre class="scala"><code data-trim data-noescape style="font-size: 1.1em;line-height: 1.25em;">
val height = 1.9d
val name = "James"
println(f"$name%s is $height%2.2f meters tall")  // James is 1.90 meters tall
	</code></pre>

	<p><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Formatter.html#detail">Документация о форматировании в Java</a></p>
</section>


<section>
	<h2>Строки</h2>
Интерполяция строк как есть (сырых строк)
	</code></pre>
	<p><code>raw</code> - интерполяция аналогичная <code>s</code>, но без служебных символов в строке</p>
		
<pre class="scala" ><code data-trim data-noescape style="font-size: 1.1em;line-height: 1.25em;">
s"a\nb"

// Результат:
a
b
</code></pre>

<br>
<pre class="scala fragment"><code data-trim data-noescape style="font-size: 1.1em;line-height: 1.25em;">
raw"a\nb"

// Результат:
a\nb
</code></pre>
</section>

<section data-markdown>>
## Строки. Документация
- `.toInt`	
- `.toDouble`	
- `.size`
- `.split(Char)`
- ...

[scala-lang.org/api/3.2.2/scala/collection/StringOps.html#](https://www.scala-lang.org/api/3.2.2/scala/collection/StringOps.html)
</section>



</section>

<!-- ====================================================================== регулярные выражения -->

<section>
<section>
	<h2>Регулярные выражения</h2>

		<pre class="scala"><code data-trim data-noescape style="font-size: 1.1em;line-height: 1.25em;">
import scala.util.matching.Regex

@main
def main() =
  // метод строки r создаст из неё экземпляр типа numberPattern
  val number_r: Regex = "[0-9]".r
  // Для записи метасимволов удобно использовать префикс raw
  val time_r: Regex = raw"\d\d:\d\d".r
  
  // проверка на полное соответствие
  number_r.matches("7");      // true
  number_r.matches("71");     // false
  number_r.matches("number"); // false
		</code></pre>
</section>


<section>
	<h2>Регулярные выражения</h2>

		<pre class="scala"><code data-trim data-noescape style="font-size: 1.1em;line-height: 1.25em;">
import scala.util.matching.Regex

@main
def main() =
  // метод строки r создаст из неё экземпляр типа numberPattern
  val number_r: Regex = "[0-9]".r

  // number_r.findAllIn("12 abc 3 8") -> итератор
  for m <- number_r.findAllIn("12 abc 3 8") do
      println(m)
	</code></pre>

<p class="fragment">Вывод</p>
		<pre class="scala fragment"><code data-trim data-noescape style="font-size: 1.1em;line-height: 1.25em;">
1
2
3
8
	</code></pre>

	<p class="fragment">Возвращаемый итератор имеет метод <code>.toList</code> </p>
</section>



<section>
	<h2>Больше примеров</h2>
<a href="https://docs.scala-lang.org/tour/regular-expression-patterns.html#inner-main">scala-lang.org/tour/regular-expression-patterns.html#inner-main</a>

<a href="https://www.scala-lang.org/api/3.2.2/scala/util/matching/Regex.html#">scala-lang.org/api/3.2.2/scala/util/matching/Regex.html#</a>
</section>


</section>


<!-- ====================================================================== управляющие конструкции -->
<section>
	<section>
		<h2>Вывод</h2>
		<pre class="" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
println("Hello, World!")
print("Hello, World!")
</code></pre>


<p class="fragment">Форматные строки</p>
<pre class="fragment" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
val p = 333.0 / 106            // 3.141509433962264
println( f"pi ≈ $p%7.3f" )
println( f"pi ≈ ${333.0/106}%7.3f" )
</code></pre>

<p class="fragment">Вывод</p>
<pre class="fragment" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
pi ≈   3.143
pi ≈   3.143
</code></pre>
	</section>


	<section>
		<h2>Ввод</h2>
		<pre class="fragment" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
// подключение трёх функций из пакета 
import scala.io.StdIn.{readLine, readInt, readLong}

val s: String = readLine()
	</code></pre>
	</section>



</section>

<!-- ====================================================================== управляющие конструкции -->




<section>
<h2>Управляющие операторы</h2>
<ul>
	<li class="fragment">  <code>if/then/else </code></li>
  <li class="fragment">  <code>for loops </code></li>
  <li class="fragment">  <code>while loops </code><br>
  	break и continue отсутствуют<br>
  </li>
  <li class="fragment">  <code>try/catch/finally </code></li>
  <li class="fragment">  <code>for expressions</code> — генераторы</li>
  <li class="fragment">  <code>match expressions</code> — сопоставление с образцом</li>

</ul>
</section>


<!-- ================================================= IF -->
<section>
<section>
	<h2>IF</h2>
	<pre class="fragment" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")
	</code></pre>
</section>


<section>
	<h2>IF</h2>
	<ul>
		<li> считается выражением </li>
	</ul>


	<pre class="fragment" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;">
val minValue = if a < b then a else b
	</code></pre>
</section>


<section>
	<h2>IF</h2>
<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;"
	data-line-numbers="5-7">
import scala.util.Random
val rand = Random
val a = rand.nextInt()
val b = rand.nextInt()
val max = 
    if (a > b) a 
    else b
	</code></pre>
</section>

</section>


<!-- ================================================= match -->
<section>
<section>
	<h2>match — сопоставление с образцом</h2>
<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;"
	data-line-numbers="">
// `i` is an integer
val day = i match
  case 0 => "Sunday"
  case 1 => "Monday"
  case 2 => "Tuesday"
  case 3 => "Wednesday"
  case 4 => "Thursday"
  case 5 => "Friday"
  case 6 => "Saturday"
  case _ => "invalid day"   // the default, catch-all
	</code></pre>
</section>

<section>
	<h2>match</h2>
	<h4>ИЛИ</h4>
<pre class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;"
	data-line-numbers="2">
val day = i match
  case 0 | 6 => "Sunday or Saturday"
  case 1 => "Monday"
  case 2 => "Tuesday"
  case 3 => "Wednesday"
  case 4 => "Thursday"
  case 5 => "Friday"
  case _ => "invalid day"   // the default, catch-all
	</code></pre>
</section>

<section>
	<h2>match</h2>
	<p style="text-align: left">
	Условие внутри case
	</p>
<pre class="fragment" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;"
	data-line-numbers="8">
import scala.util.Random

val x: Int = Random.nextInt(10)

println(x)

x match
  case x if (x%2==0) => "even"
  case 1 => "one"
  case 3 => "three"
  case _ => "other"
	</code></pre>
</section>



<section>
	<h2>match</h2>
	<h4>Извлечение значения</h4>

	<p style="text-align: left">
	Вместо значения в case можно указать переменную, в которую это значение запишется. Так как переменная будет всегда равна проверяемому значению, такая ветка будет срабатывать всегда.
	</p>

<pre class="fragment" class="scala"><code data-trim data-noescape style="font-size: 1.3em;line-height: 1.25em;"
	data-line-numbers="9">
val day = i match
  case 0 => "Sunday"
  case 1 => "Monday"
  case 2 => "Tuesday"
  case 3 => "Wednesday"
  case 4 => "Thursday"
  case 5 => "Friday"
  case 6 => "Saturday"
	case x => s"$x - not a valid day number" // the default, catch-all
	</code></pre>
</section>


<section  style="height: 100vh;">
	<h2>match</h2>
	<h4>Извлечение значения объекта</h4>

	<p style="text-align: left">

	</p>

<pre class="fragment"  style="height: 40vh;"><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
	data-line-numbers="1|2-17|18-30">
case class Email(sender: String, title: String, body: String)

// возможные варианты для match
// send to spam
//val x = new Email("Spammer", "Not a Spam", "Hello, dear friend")
// delete
val x = new Email("Manager", "important!!!!", "Hello, dear friend")          
//val x = new Email("Manager2", "important!!!!", "Hello, dear friend")
// do nothing
//val x = new Email("Vasya", "qwerty", "Hello, dear friend")  

// 2 или более восклицательных знака среди всего остального, 
// выражение должно быть в скобках для обозначения места для подстановки строки
val title_reg   = "(.*!{2,}.*)".r   
// 2 или более восклицательных знака среди всего остального
val title_reg22 =  ".*!{2,}.*".r     

x match
// проверка по полю sender, с извлечением значения из поля title в переменную title1
case Email("Spammer", title1, _)           		=> s"send <$title1> to spam"
// проверка по последнему полю
case Email(_, _, "money")                  		=> "mark important"
// проверка по точному совпадению с первым полем, 
// извлечение значения второго поля в title22, проверка по регулярному выражению
case Email("Manager", title_reg(title22), _) 	=> "delete"
// значение для проверки в регулярном выражении можно и не извлекать в переменную, 
// ведь и так понятно что туда подставлять
case Email("Manager2", title_reg22(), _) 			=> "also delete"
// если ничего не сработало
case _ => "do nothing"
	</code></pre>
</section>



<section>
	<h2>Пример сопоставления с образцом для аргументом командной строки</h2>

</section>


</section>


<!-- ====================================================================== for -->
<section>
<section>
	<h2>FOR</h2>

	<div  class="fragment">
		Цикл со счётчиком
		<pre  style=""><code data-trim data-noescape style="font-size: 1.25em;line-height: 1.05em;" class="scala">
		for i <- 1 to 10 do 
			  println(i)
			</code></pre>
	</div>
	

	<br>
	<div  class="fragment">
		Совместный цикл (цикл по коллекции)
		<pre  style=""><code data-trim data-noescape style="font-size: 1.25em;line-height: 1.05em;" class="scala"
			data-line-numbers="3-4">
		val ints = List(1, 2, 3, 4, 5)

		for i <- ints do 
		    println(i)
			</code></pre>

			<code class="frgment">i <- ints</code> - генератор 
	</div>





</section>


<section>
	<h2>FOR</h2>
	<ul class="fragment">
		<li>Заголовок цикла по коллекции может включать условия (guards)</li>
		<li>Заголовок можно записывать в несколько строк</li>
	</ul>

	<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="2-7">
val ints = List(1, 2, 3, 4, 5)

for
  i <- ints
  if i % 2 == 0
do
  println(i)
		</code></pre>

<br>
<p class="fragment">Вывод</p>
<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala">
2
4
		</code></pre>

</section>


<section>
	<h2>FOR</h2>
	<ul class="fragment">
		<li>для записи вложенных циклов достаточно одного оператора for</li>
	</ul>

	<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="2-7">
for
  i <- 1 to 3
  j <- 'a' to 'c'
do
  println(s"i = $i, j = $j")  
		</code></pre>

<br>
<p class="fragment">Вывод</p>
<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala">
i = 1, j = a
i = 1, j = b
i = 1, j = c
i = 2, j = a
i = 2, j = b
i = 2, j = c
i = 3, j = a
i = 3, j = b
i = 3, j = c
		</code></pre>

</section>


<section>
	<h2>FOR</h2>
	<ul class="fragment">
		<li>Условия можно помещать и во вложенных циклах</li>
		<li>В примере ниже они будут проверяться каждую итерацию самого вложенного цикла</li>
	</ul>

	<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="">
for
  i <- 1 to 10
  j <- 'a' to 'c'
  if i % 2 == 0
  if j != 'b'
do
  println(s"i = $i, j = $j")  
		</code></pre>

<br>
<p class="fragment">Вывод</p>
<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala">
i = 2, j = a
i = 2, j = c
i = 4, j = a
i = 4, j = c
i = 6, j = a
i = 6, j = c
i = 8, j = a
i = 8, j = c
i = 10, j = a
i = 10, j = c
		</code></pre>

</section>

<section>
	<h2>Выражения на основе for (генераторы)</h2>
	<ul class="fragment">
		Принцип работы похож на list comprehension из Python
	</ul>

	<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="2|4-5">
val ints = List(1, 2, 3, 4, 5)
val doubles = for i <- ints yield i * 2

// Результат List[Int] = 
List(2, 4, 6, 8, 10)
		</code></pre>

<br>
<p class="fragment">Такая запись удобна для преобразования списков</p>
<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="1-2|4-5">
val names = List("chris", "ed", "maurice")
val capNames = for name <- names yield name.capitalize

// Результат List[String] =
List(Chris, Ed, Maurice)
		</code></pre>
</section>



</section>



<!-- ====================================================================== for -->


<section data-visibility="hidden">
	Например:


	while используется редко, т.к. есть рекурсия. break и continue отсутствуют (как и return в середине функции).
	do ... while не используется.

	for

	for ( i <- 1 to 10 )
	    println(i)
	    
	// в обратном порядке
	for ( i <- 10 to 1 by -1)
	  println(i)
	  
	// цикл по коллекции  
	for ( i <- Vector(1,2,3))
	  println(i)

	Можно использовать внутри конструкции, похожей как в list comprehension, в том числе с условием.

	println( for (i <- 1 to 10) yield i*i)    // 1, 4, 9, ...

	// квадраты чисел кратных трём
	println( for (i <- 1 to 100  if i%3 == 0) 
	      yield i*i
	)    // 9, 36, 81, 144 

	Можно указывать произвольное число действий в заголовке цикла. Это создаст вложенный цикл:

	for ( i <- 1 to 10;  j <- 1 to 10)
	    print(f"$i,$j  ")

	Код с фигурными скобками вместо круглых можно записать в несколько строк, не разделяя операторы точкой с запятой.

	for { i <- 1 to 10
	      j <- 1 to 10 }
	    print(f"$i,$j;  ")

	В тело цикла можно включить условие, контролирующее изменение счётчика

	for { i <- 1 to 5
	      j <- 1 to 5 if i >= j}
	    print(f"$i,$j;  ")

	Вывод

	1,1;  2,1;  2,2;  3,1;  3,2;  3,3;  4,1;  4,2;  4,3;  4,4;  5,1;  5,2;  5,3;  5,4;  5,5;
</section>



<!-- ====================================================================== def -->
<section>
	<section>
		<h2>Методы</h2>
		<pre class=""  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="">
def foo(x:Int):Double = 42.0 + x    // Double -- тип возвращаемого значения
		</code></pre>
		<ul>
			<li class="fragment">Оператор return не используется, возвращаемое значение -- это значение последнего выражения внутри функции; (это тоже упрощает анализ кода, поощряет написание функций где невозможен выход в неожиданном месте) </li>
			
			<li class="fragment">Тип возвращаемого значения может быть выведен автоматически (кроме рекурсивных функций)</li>
		</ul>
		
	</section>

	<section>
		<h2>Методы</h2>
		<ul>
			<li class="fragment">Тело метода можно заключить в фигурные скобки. Но можно и не заключать</li>
		</ul>


		<pre class=""  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="1|4-7">
def foo(x:Int) = 42.0+x     

// или
def foo(x:Int) = {
    println("Hello, World!")
    42+x                      // возвращаемое значение -- значение последнего выражения в функции
}
		</code></pre>
		
		<ul class="fragment">
			<li>Функции объявлять можно где угодно, в том числе внутри других функций</li>
		</ul>

<pre class="fragment"  style=""><code data-trim data-noescape style="font-size: 1em;line-height: 1.05em;" class="scala"
		data-line-numbers="">
def foo(x:Int) = {
    
    def hello_world() = println("Hello, World!")

  	hello_world()
    42+x                      // возвращаемое значение -- значение последнего выражения в функции
}

hello_world
// ошибка: hello_world вне области видимости

foo()
</code></pre>
		
	</section>



	<section data-markdown>
		## Функции
		Функция, сама по себе, являясь значением некоторого функционального типа, может быть записана и в переменную, подобно анонимным функциям в языке C++.
Например:

  ```scala
  val foo: Int => Double = (x:Int) => 42.0 + x
  ```

где

- `Int => Double` - тип функции, принимающей Int и возвращавший Double
- `=` - присваивание значения, в данном случае тела функции
- `(x:Int) => 42.0 + x` - тело функции

	</section>


</section>


			<!-- slides -->
			</div>		

			<!-- reveal -->
		</div>			

		<script src="dist/reveal.js"></script>
		<script src="plugin/zoom/zoom.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/search/search.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>

			// Also available as an ES module, see:
			// https://revealjs.com/initialization/
			Reveal.initialize({
				controls: true,
				progress: true,
				center: true,
				hash: true,

				// font-size: 20,

				width: 1280,
  			height: 960,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealHighlight ]
			});

		</script>

	</body>
</html>
